<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>A curious mind... (scientific programming)</title><link>http://michaelaye.blogspot.com/</link><description></description><language>en</language><lastBuildDate>Mon, 04 Aug 2014 22:23:49 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>polyfit</title><link>http://michaelaye.blogspot.com/posts/201306polyfit.html</link><dc:creator>Michael Aye</dc:creator><description>&lt;div dir="ltr" style="text-align: left;"&gt;A follow-up to the previous post.&lt;br&gt;&lt;br&gt;Polynomial fitting is also very easy with the numpy packages polyfit and poly1d.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;blockquote&gt;In [196]: x = range(100)&lt;br&gt;In [197]: y = randn(100)&lt;br&gt;In [198]: plot(x,y)&lt;br&gt;Out[198]: []&lt;/blockquote&gt;Here I am asking polyfit to fit me a 2nd degree polynomial.&lt;br&gt;&lt;blockquote&gt;In [199]: polyfit(x,y,2)&lt;br&gt;Out[199]: array([-0.00018313,  0.01669275, -0.09621319])&lt;/blockquote&gt;The polyfit function returns the polynomial coefficients in a list.&lt;br&gt;If I want to use them directly as a fit function, just embed them in a new polynomial object:&lt;br&gt;&lt;blockquote&gt;In [200]: fitfunc = poly1d(polyfit(x,y,2))&lt;br&gt;In [201]: plot(x,fitfunc(x))&lt;br&gt;Out[201]: []&lt;/blockquote&gt;Saving the plot like this&lt;br&gt;&lt;blockquote&gt;In [202]: savefig('/Users/maye/Desktop/blog_polyfit.png')&lt;/blockquote&gt;&lt;div&gt;and looks like this:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-rnC7uQD6xKc/Ua5u7uN3NQI/AAAAAAAAIIo/HTbo7T4EIA8/s1600/blog_polyfit.png" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="480" src="http://3.bp.blogspot.com/-rnC7uQD6xKc/Ua5u7uN3NQI/AAAAAAAAIIo/HTbo7T4EIA8/s640/blog_polyfit.png" width="640"&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;</description><category>Python</category><category>scientific programming</category><guid>http://michaelaye.blogspot.com/posts/201306polyfit.html</guid><pubDate>Tue, 04 Jun 2013 23:49:00 GMT</pubDate></item><item><title>Polynomials with Python</title><link>http://michaelaye.blogspot.com/posts/201305polynoms-with-python.html</link><dc:creator>Michael Aye</dc:creator><description>&lt;div dir="ltr" style="text-align: left;"&gt;&lt;div class="tr_bq"&gt;Seriously, can it be any easier? ;)&lt;/div&gt;&lt;br&gt;If you are not in a pylab session, import the module like this:&lt;br&gt;&lt;blockquote&gt;In [148]: from numpy import poly1d&lt;/blockquote&gt; Otherwise, just "import poly1d" should work.&lt;br&gt;Now let's get a polynomial for the coefficients of [3,2,1] (always in decreasing order!):&lt;br&gt;&lt;blockquote&gt;In [149]: p = poly1d([3,2,1])&lt;/blockquote&gt;Printing it provides a semi-analytical printout:&lt;br&gt;&lt;blockquote&gt;In [150]: print p&lt;br&gt;   2&lt;br&gt;3 x + 2 x + 1&lt;/blockquote&gt;Applying new x values to it is easy, because the poly1d object is a function:&lt;br&gt;&lt;blockquote&gt;In [152]: newx = linspace(0,10,10)&lt;br&gt;In [153]: p(newx)&lt;br&gt;Out[153]:&lt;br&gt;array([   1.        ,    6.92592593,   20.25925926,   41.        ,&lt;br&gt;         69.14814815,  104.7037037 ,  147.66666667,  198.03703704,&lt;br&gt;        255.81481481,  321.        ])&lt;/blockquote&gt;Lots of other things are possible with this object. IPython's object inspection makes it easy to discover them:&lt;br&gt;&lt;blockquote&gt;In [154]: p.&lt;br&gt;p.coeffs    p.deriv     p.integ     p.order     p.variable&lt;br&gt;&lt;br&gt;In [155]: p.deriv()&lt;br&gt;Out[155]: poly1d([6, 2])&lt;br&gt;In [156]: pderiv = p.deriv()&lt;br&gt;In [157]: print pderiv&lt;br&gt;6 x + 2&lt;/blockquote&gt;Roots for this polynomial can be either determined by the roots function that is imported in a pylab session (or importable like from numpy import roots)&lt;br&gt;&lt;blockquote&gt;In [158]: roots(p)&lt;br&gt;Out[158]: array([-0.33333333+0.47140452j, -0.33333333-0.47140452j])&lt;br&gt;In [159]: p.r&lt;br&gt;Out[159]: array([-0.33333333+0.47140452j, -0.33333333-0.47140452j])&lt;/blockquote&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;PS: One of these days I really have to find out how to do code high-lighting in Blogger, or, preferably, go all the way and do IPython notebook posts.&lt;/div&gt;</description><category>Python</category><category>scientific programming</category><guid>http://michaelaye.blogspot.com/posts/201305polynoms-with-python.html</guid><pubDate>Fri, 31 May 2013 17:28:00 GMT</pubDate></item><item><title>Intuitive division in Python</title><link>http://michaelaye.blogspot.com/posts/201001intuitive-division-in-python.html</link><dc:creator>Michael Aye</dc:creator><description>&lt;p&gt;When one is hot-coding some idea, it is all about writing down an idea fast, not pretty (even so it's quite hard to write ugly code in Python due to its indental paradigm), not clean or precise, just trying out an idea.&lt;/p&gt;&lt;div&gt;It is then that it could happen to overlook that a division of 2 integer numbers is forcing an integer solution of this calculation (the underlying C-paradigm for divisions in Python is enforcing this), so 3/4 is 0, not 0.75, because one forgot to write something like 3/4.0 to enforce the floating point division.&lt;/div&gt;&lt;div&gt;Many errors in un-counted Python (and C) classes were caused by this intricacy, maybe even some good ideas have been discredited because the code produced weird results. And because of the caused frustrations, the Python inventors have decided to get rid of this, beginning with the 3.x versions of Python, so 3/4 is actually 0.75.&lt;/div&gt;&lt;div&gt;And because this was such a great idea, it was decided to make it available as an option in Python 2.x (before you judge this as a minor change, admit to yourself how often you have been caught by this bug!?).&lt;/div&gt;&lt;div&gt;So, to enable this 'safe' division in Python 2.x code, you have to write the following line before all other imports:&lt;/div&gt;&lt;div&gt;&lt;i&gt;from __future__ import division&lt;/i&gt;&lt;/div&gt;&lt;div&gt;(thats 2 underscores in front AND behind the &lt;i&gt;future&lt;/i&gt;)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Enjoy your hot-coding now! ;)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;</description><category>Python</category><category>scientific programming</category><guid>http://michaelaye.blogspot.com/posts/201001intuitive-division-in-python.html</guid><pubDate>Sun, 17 Jan 2010 18:00:00 GMT</pubDate></item></channel></rss>